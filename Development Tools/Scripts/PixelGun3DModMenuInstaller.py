import os
import subprocess
import platform
import warnings
import shutil
from xml.etree import ElementTree


class IllegalArgumentException(ValueError):
    pass


class FolderExistsError(FileExistsError):
    pass


class Logging:
    def __init__(self,
                 colorized=True,
                 printwarnings=True,
                 printimportant=True,
                 printveryimportant=True,
                 printsuperimportant=True,
                 printspecial=True,
                 donotprintsuccessinfo=False,
                 overridedonotprintifspecial=True,
                 printall=True,
                 printnone=False,
                 ):
        self.colorized = colorized
        self.printwarnings = printwarnings
        self.printimportant = printimportant
        self.printveryimportant = printveryimportant
        self.printsuperimportant = printsuperimportant
        self.printspecial = printspecial
        self.donotprintsuccessinfo = donotprintsuccessinfo
        self.overridedonotprintifspecial = overridedonotprintifspecial
        self.printall = printall
        self.printnone = printnone
        self.Log = []

    def log(self, message: str, important=True, veryimportant=False, superimportant=False, successinfo=False, special=False):
        # Todo: Colored logs
        self.Log.append(message)
        if not(special and self.overridedonotprintifspecial):
            if self.printnone:
                return
            if successinfo and self.donotprintsuccessinfo:
                return
        if superimportant and (self.printsuperimportant or self.printall):
            if self.colorized:
                self.printmessage_colorized(message, "SuperImportant", special)
            else:
                self.printmessage(message, "SuperImportant", special)
        elif veryimportant and (self.printveryimportant or self.printall):
            if self.colorized:
                self.printmessage_colorized(message, "VeryImportant", special)
            else:
                self.printmessage(message, "VeryImportant", special)
        elif important and (self.printsuperimportant or self.printall):
            if self.colorized:
                self.printmessage_colorized(message, "Important", special)
            else:
                self.printmessage(message, "Important", special)
        elif (special and self.printspecial) or self.printall:
            if self.colorized:
                self.printmessage_colorized(message, special=special)
            else:
                self.printmessage(message, special=special)

    def printlog(self):
        print(self.Log)

    @staticmethod
    def printmessage(message: str, messagetype: str=None, special=False):
        if messagetype:
            if special:
                print(f"[{messagetype}] [Special]: {message}")
            else:
                # Includes Warning Type
                print(f"[{messagetype}]: {message}")
        else:
            if special:
                print(f"[Special]: {message}")
            else:
                # Includes Warning Type
                print(f"{message}")

    @staticmethod
    def printmessage_colorized(message: str, messagetype: str = None, special=False):
        """
        Generated by ChatGTP!
        """
        colors = {
            "Important": "\033[95m",
            "VeryImportant": "\033[96m",
            "SuperImportant": "\033[93m",
            "Info": "\033[94m",
            "Warning": "\033[91m",
            "Special": "\033[92m",
            "reset": "\033[0m"
        }
        if messagetype:
            if special:
                print(f"{colors['Special']}[{messagetype}] [Special]: {message}{colors['reset']}")
            else:
                if messagetype in colors:
                    print(f"{colors[messagetype]}[{messagetype}]: {message}{colors['reset']}")
                else:
                    print(f"[{messagetype}]: {message}")
        else:
            if special:
                print(f"{colors['Special']}[Special]: {message}{colors['reset']}")
            else:
                print(f"{message}")

    def warning(self, message: str):
        self.Log.append(f"[Warning]: {message}")
        if self.printwarnings:
            if self.colorized:
                self.printmessage_colorized(message, "Warning")
            else:
                self.printmessage(message, "Warning")


def readaftersubstring(sub: str, s: str, lengthwarning=True) -> str:
    """
    This function is based off of
    https://stackoverflow.com/questions/12572362/how-to-get-a-string-after-a-specific-substring/57064170#57064170

    Returns the substring after the delimiter
    If the substring is not found in the string, returns the whole string

    Example:
        String: "Split this string by delimiter"
        Sub:    "string"
        Return: " by delimiter"

    Arguments:
        s: string to split
        sub: delimiter to read after
        lengthwarning: whether to throw a warning if the arguments do not make sense (this is purely
        to catch bugs)

    Return:
        the partition of the string that comes after the delimiter
    """
    if lengthwarning and len(sub) > len(s):
        warnings.warn(f"Call to readaftersubstring(sub={sub}, str={s}): substring is longer than full string",
                      SyntaxWarning)
    prefix, found, suffix = s.partition(sub)
    if not found:
        suffix = prefix
    return suffix


def readbeforesubstring(sub: str, s: str, lengthwarning=True) -> str:
    """
    This function is based off of
    https://stackoverflow.com/questions/12572362/how-to-get-a-string-after-a-specific-substring/57064170#57064170

    Returns the substring before the delimiter
    If the substring is not found in the string, returns the whole string

    Example:
        String: "Split this string by delimiter"
        Sub:    "string"
        Return: "Split this "

    Arguments:
        s: string to split
        sub: delimiter to read before
        lengthwarning: whether to throw a warning if the arguments do not make sense (this is purely
        to catch bugs)

    Return:
        the partition of the string that comes before the delimiter
    """
    if lengthwarning and len(sub) > len(s):
        warnings.warn(f"Call to readbeforesubstring(sub={sub}, str={s}): substring is longer than full string",
                      SyntaxWarning)
    prefix, found, suffix = s.partition(sub)
    if not found:
        prefix = suffix
    return prefix


def parsexmlfile(path):
    logging.log(f"Parsing xml file {path}...", False)
    parsedxml = ElementTree.parse(path)
    logging.log(f"Successfully parsed xml file {path}", False, successinfo=True)
    return parsedxml


def read_file(path, encoding='utf8', binary=False):
    if binary:
        logging.log(f"Reading file {path} in binary mode...", False)
    else:
        logging.log(f"Reading file {path} with encoding {encoding}...", False)
    if binary:
        with open(path, 'rb') as f:
            content = f.read()
    else:
        with open(path, 'r', encoding=encoding) as f:
            content = f.read()
    if binary:
        logging.log(f"Successfully read file {path} in binary mode", False, successinfo=True)
    else:
        logging.log(f"Successfully read file {path} with encoding {encoding}", False, successinfo=True)
    return content


def write_file(path, new, binary=False):
    if binary:
        logging.log(f"Writing to file {path} in binary mode...", False)
    else:
        logging.log(f"Writing to file {path}...", False)
    if binary:
        with open(path, 'wb') as f:
            f.write(new)
    else:
        with open(path, 'w') as f:
            f.write(new)
    if binary:
        logging.log(f"Successfully wrote to file {path} in binary mode", False, successinfo=True)
    else:
        logging.log(f"Successfully wrote to file {path}", False, successinfo=True)


def removedirectory(path, loggingimportance=False):
    logging.log(f"Removing directory {path}...", loggingimportance)
    # noinspection PyExceptClausesOrder
    try:
        shutil.rmtree(path)
    except OSError as exception:
        #raise OSError(exception)
        logging.warning(f"OSError exception occurred removing directory {path}: {exception}. Ignoring exception.")
    except IOError as exception:
        #raise IOError(exception)
        logging.warning(f"IOError exception occurred removing directory {path}: {exception}. Ignoring exception.")
    except shutil.Error as exception:
        # shutil loves to raise long error messages (sometimes, it literally lists every single file it fails to copy),
        # so we truncate them
        if len(exception) > 500:
            exception = exception[:500] + "... [TRUNCATED]"
        logging.warning(f"shutil.Error exception occurred removing directory {path}: {exception}. Ignoring exception.")
    else:
        logging.log(f"Successfully removed directory {path}", loggingimportance, successinfo=True)


def removefile(path, loggingimportance=False):
    logging.log(f"Removing file {path}...", loggingimportance)
    # noinspection PyExceptClausesOrder
    try:
        os.remove(path)
    except OSError as exception:
        #raise OSError(exception)
        logging.warning(f"OSError exception occurred removing file {path}: {exception}. Ignoring exception.")
    except IOError as exception:
        #raise IOError(exception)
        logging.warning(f"IOError exception occurred removing file {path}: {exception}. Ignoring exception.")
    except Exception as exception:
        logging.warning(f"Exception occurred removing file {path}: {exception}. Ignoring exception.")
    else:
        logging.log(f"Successfully removed file {path}", loggingimportance, successinfo=True)


def copydirectory(oldpath, newpath, cancelifexists=False, loggingimportance=False):
    logging.log(f"Copying directory {oldpath} to {newpath}...", loggingimportance)
    assertfolderexists(oldpath)
    if path.isdir(newpath):
        if cancelifexists:
            raise Exception(f"Directory {newpath} already exists")
        else:
            logging.log(f"Overwriting directory {newpath}...", True, special=True)
            removedirectory(newpath, loggingimportance=False)
    # noinspection PyExceptClausesOrder
    try:
        shutil.copytree(oldpath, newpath)
    except OSError as exception:
        # raise OSError(exception)
        logging.warning(f"OSError exception occurred copying directory {oldpath} to {newpath}: {exception}. Ignoring exception.")
    except IOError as exception:
        # raise IOError(exception)
        logging.warning(f"IOError exception occurred copying directory {oldpath} to {newpath}: {exception}. Ignoring exception.")
    except Exception as exception:
        logging.warning(f"shutil.Error exception occurred copying directory {oldpath} to {newpath}: {exception}. Ignoring exception.")
    else:
        logging.log(f"Successfully copied directory {oldpath} to {newpath}", loggingimportance, successinfo=True)


def copyfile(oldpath, newpath, cancelifexists=False, loggingimportance=False):
    logging.log(f"Copying file {oldpath} to {newpath}...", loggingimportance)
    assertfileexists(oldpath)
    if os.path.isfile(newpath):
        if cancelifexists:
            raise Exception(f"File {newpath} already exists")
        else:
            logging.log(f"Overwriting file {newpath}...", True, special=True)
            removefile(newpath, loggingimportance=False)
    # noinspection PyExceptClausesOrder
    try:
        shutil.copy(oldpath, newpath)
    except OSError as exception:
        # raise OSError(exception)
        logging.warning(f"OSError exception occurred copying file {oldpath} to {newpath}: {exception}. Ignoring exception.")
    except IOError as exception:
        # raise IOError(exception)
        logging.warning(f"IOError exception occurred copying file {oldpath} to {newpath}: {exception}. Ignoring exception.")
    except Exception as exception:
        logging.warning(f"shutil.Error exception occurred copying file {oldpath} to {newpath}: {exception}. Ignoring exception.")
    else:
        logging.log(f"Successfully copied file {oldpath} to {newpath}", loggingimportance, successinfo=True)


def createdirectory(path, overwriteifexists=False, loggingimportance=False):
    logging.log(f"Creating directory {path}...", loggingimportance)
    if os.path.isdir(path):
            logging.log(f"Directory {path} already exists", loggingimportance, successinfo=True)
            if overwriteifexists:
                logging.log(f"Overwriting directory {path}...", True, special=True)
                removedirectory(path, loggingimportance=False)
            else:
                return
    # noinspection PyExceptClausesOrder
    try:
        os.mkdir(path)
    except OSError as exception:
        # raise OSError(exception)
        logging.warning(f"OSError exception occurred creating directory {path}: {exception}. Ignoring exception.")
    except IOError as exception:
        # raise IOError(exception)
        logging.warning(f"IOError exception occurred creating directory {path}: {exception}. Ignoring exception.")
    except Exception as exception:
        logging.warning(f"Exception occurred creating directory {path}: {exception}. Ignoring exception.")
    else:
        logging.log(f"Successfully created directory {path}", loggingimportance, successinfo=True)

def assertfileexists(path):
    if os.path.isdir(path):
        raise IsADirectoryError(f"Expected file at path {path}, got folder.")
    if not os.path.isfile(path):
        raise FileNotFoundError(f"Could not find file at path {path}")


def assertfolderexists(path):
    if os.path.isfile(path):
        raise NotADirectoryError(f"Expected folder at path {path}, got file.")
    if not os.path.isdir(path):
        raise FileNotFoundError(f"Could not find folder at path {path}")


def getimmediate(directory, folders=True, files=True):
    if folders and files:
        return [os.path.join(directory, sub) for sub in os.listdir(directory)]
    elif folders:
        return [os.path.join(directory, sub) for sub in os.listdir(directory) if os.path.isdir(os.path.join(directory, sub))]
    elif files:
        return [os.path.join(directory, sub) for sub in os.listdir(directory) if os.path.isfile(os.path.join(directory, sub))]
    else:
        warnings.warn("Call to getimmediate without folders or files will return empty list", SyntaxWarning)
        return []


def removefileextension(path):
    return os.path.splitext(path)[0]


def getfileextension(path):
    fileextension = os.path.splitext(path)[1]
    return readaftersubstring(".", fileextension) if fileextension != "" else ""


class ModMenuInstall:
    def __init__(self,
                 apkpath,
                 newapkpath,
                 modmenuapkpath,
                 modmenulibname,
                 requiredpermissions=None,
                 newappname=None,
                 deletelibs=None,
                 overwriteifexists=False,
                 cancelifexists=False):
        if deletelibs is None:
            deletelibs = ()
        if requiredpermissions is None:
            requiredpermissions = set()
        else:
            requiredpermissions = set(requiredpermissions)
        requiredpermissions.add("android.permission.SYSTEM_ALERT_WINDOW")
        logging.log(f"Installing mod menu {modmenuapkpath} to {newapkpath}...", True, True, True)
        logging.log("Preparing for mod menu installation...", True, True, True)
        paths = {"apkpath": apkpath, "newapkpath": newapkpath, "modmenuapkpath": modmenuapkpath}
        for pathname, path in zip(paths.keys(), paths.values()):
            if getfileextension(path) == "apk":
                # Though assertfolderexists will work fine, it may save someone trouble to give them a more direct
                # error message if they accidentally supply an apk file rather than a decompiled apk folder
                if pathname == "newapkpath":
                    raise IllegalArgumentException(f"Expected folder for {pathname}, got apk file {path}")
                else:
                    raise IllegalArgumentException(f"Expected decompiled apk folder for {pathname}, got apk file"
                                                   f" {path}")
        assertfolderexists(apkpath)
        assertfolderexists(modmenuapkpath)
        if getfileextension(modmenulibname) != "so":
            raise IllegalArgumentException(f"Expected name of mod menu lib file, ex \"libModMenu.so\", got {modmenulibname}."
                            f" Did you forget to add '.so' to the end?")
        self.apkpath = os.path.normpath(apkpath)
        self.newapkpath = os.path.normpath(newapkpath)
        self.modmenuapkpath = os.path.normpath(modmenuapkpath)
        self.modmenulibname = modmenulibname
        self.deletelibs = deletelibs
        # if os.path.isdir(self.newapkpath):
        #     if cancelifexists:
        #         raise FolderExistsError(f"Modded apk already exists at path {self.newapkpath}.")
        #     elif not overwriteifexists:
        #         logging.log(f"Modded apk already exists at path {self.newapkpath}."
        #                     f" Using this modded apk instead of overwriting it.",
        #                     True, True, special=True)
        #         self.newapkalreadyexists = True
        #     else:
        #         logging.log("Overwriting modded apk at path {self.newapkpath}...",
        #                     True, True, special=True)
        #         self.newapkalreadyexists = False
        # else:
        #     self.newapkalreadyexists = False
        if os.path.isdir(self.newapkpath) and overwriteifexists:
            logging.log("Overwriting modded apk at path {self.newapkpath}...",
                        True, True, special=True)
            self.newapkalreadyexists = False
        elif os.path.isdir(self.newapkpath) and cancelifexists:
                raise FolderExistsError(f"Modded apk already exists at path {self.newapkpath}.")
        elif os.path.isdir(self.newapkpath) and not overwriteifexists:
                logging.log(f"Modded apk already exists at path {self.newapkpath}."
                            f" Using this modded apk instead of overwriting it.",
                            True, True, special=True)
                self.newapkalreadyexists = True
        else:
            self.newapkalreadyexists = False
        if not self.newapkalreadyexists:
            copydirectory(self.apkpath, self.newapkpath, cancelifexists=False, loggingimportance=True)
        logging.log("Collecting data for mod menu installation...", True, True, True)
        logging.log("Finding smali folders...", True, True)
        self.smalifolders = self._getsmalifolders()
        logging.log("Finding mod menu smali folder...", True, True)
        self.modmenusmalifolder = self._getmodmenusmalifolder()
        logging.log("Finding lib folders...", True, True)
        self.libfolders = self._getlibfolders()
        logging.log("Finding mod menu lib folders...", True, True)
        self.modmenulibfolders = self._getmodmenulibfolders()
        logging.log("Finding AndroidManifest.xml...", True, True)
        self.androidmanifestpath = self._getandroidmanifest()
        logging.log("Finding mainactivity...", True, True)
        self.mainactivity = self._getmainactivity()
        logging.log("Finding mainactivity file...", True, True)
        self.mainactivitypath = self._getmainactivitypath()
        logging.log("Installing mod menu...", True, True, True)
        logging.log("Adding permissions...", True, True)
        self.addpermissions(requiredpermissions)
        if not self.newapkalreadyexists:
            logging.log("Adding launcher service...", True, True)
            self.addlauncherservice()
            logging.log("Adding mod menu smali...", True, True)
            self.addmodmenusmali()
        logging.log("Adding mod menu lib...", True, True)
        self.addmodmenulib()
        if newappname:
            logging.log(f"Changing app name to \"{newappname}\"...", True, True)
            self.changeappname(newappname)
        logging.log(f"Successfully installed mod menu!", True, True, True)

    def _getandroidmanifest(self):
        logging.log(f"Finding AndroidManifest.xml in {self.newapkpath}...", True)
        manifestpath = os.path.join(self.newapkpath, "AndroidManifest.xml")
        assertfileexists(manifestpath)
        logging.log(f"Found AndroidManifest.xml at path {manifestpath}", True, successinfo=True)
        return manifestpath

    def _getmainactivity(self):
        logging.log(f"Finding mainactivity of apk {self.newapkpath}...", True)
        parsedxml = parsexmlfile(self.androidmanifestpath)
        root = parsedxml.getroot()
        try:
            mainactivity = root.findall("application/activity")[0].attrib[
                "{http://schemas.android.com/apk/res/android}name"]
        except Exception:
            raise Exception(
                f"Failed to determine mainactivity of apk {self.newapkpath}"
                f" via AndroidManifest.xml at path {self.androidmanifestpath}")
        else:
            logging.log(f"Found mainactivity: {mainactivity}", True, successinfo=True)
            return mainactivity

    def _getmainactivitypath(self, recurse=0):
        if recurse == 0:
            logging.log(f"Finding mainactivity file in {self.newapkpath}...", True)
        relativepath = self.mainactivity.replace(".", "\\", (self.mainactivity.count(".") - recurse))\
                       + ".smali"
        found = False
        # It's impossible for mainactivitypath to be referenced before assignment in line 130
        # However, my ide isn't smart enough to know that, so we set it to None to stop it from complaining
        mainactivitypath = None
        for smalifolder in self.smalifolders:
            mainactivitypath = os.path.join(smalifolder, relativepath)
            if os.path.isfile(mainactivitypath):
                found = True
                break
        if found:
            logging.log(f"Found mainactivity file at path {mainactivitypath}", True)
            return mainactivitypath
        elif recurse < self.mainactivity.count("."):
            return self._getmainactivitypath(recurse + 1)
        else:
            raise Exception(f"Failed to find mainactivity file ({self.mainactivity}) in {self.newapkpath}")


    def _getsmalifolders(self):
        logging.log(f"Finding all smali folders in {self.newapkpath}...", True)
        folders = getimmediate(self.newapkpath, True, False)
        smalifolders = [folder for folder in folders if os.path.basename(folder).startswith("smali")]
        if not smalifolders:
            raise Exception(f"Found no smali folders in {self.newapkpath}")
        logging.log(f"Found all smali folders", True, successinfo=True)
        return smalifolders

    def _getmodmenusmalifolder(self):
        logging.log(f"Finding smali folder in {self.modmenuapkpath}...", True)
        modmenusmalipath = os.path.join(self.modmenuapkpath, "smali")
        assertfolderexists(modmenusmalipath)
        modmenusmalifolders = getimmediate(modmenusmalipath, True, False)
        if not modmenusmalifolders:
            raise Exception(f"Found no subfolders in mod menu smali folder at {modmenusmalipath}")
        if len(modmenusmalifolders) > 1:
            raise Exception(f"Found multiple subfolders in mod menu smali folder at {modmenusmalipath}, only expected one")
        logging.log(f"Found mod menu smali folder", True, successinfo=True)
        return modmenusmalifolders[0]

    def _getlibfolders(self):
        logging.log(f"Finding lib folders in {self.newapkpath}...", True)
        libpath = os.path.join(self.newapkpath, "lib")
        assertfolderexists(libpath)
        libfolders = getimmediate(libpath, True, False)
        if not libfolders:
            raise Exception(f"Found no subfolders in lib folder at {libpath}")
        logging.log(f"Found lib folders", True, successinfo=True)
        return libfolders

    def _getmodmenulibfolders(self):
        logging.log(f"Finding lib folders in {self.modmenuapkpath}...", True)
        modmenulibpath = os.path.join(self.modmenuapkpath, "lib")
        assertfolderexists(modmenulibpath)
        modmenulibfolders = getimmediate(modmenulibpath, True, False)
        if not modmenulibfolders:
            raise Exception(f"Found no subfolders in mod menu lib folder at {modmenulibpath}")
        logging.log(f"Found mod menu lib folders", True, successinfo=True)
        return modmenulibfolders

    def changeappname(self, newappname):
        logging.log(f"Changing application name to \"{newappname}\" in AndroidManifest.xml..", True)
        logging.warning("Changeappname function has not been implemented yet")
        return
        logging.log(f"Updating AndroidManifest.xml file...", False)
        content = read_file(self.androidmanifestpath)
        write_file(self.androidmanifestpath, content)
        logging.log(f"Successfully updated AndroidManifest.xml file", False, successinfo=True)
        logging.log(f"Successfully changed application name to \"{newappname}\" in AndroidManifest.xml", True, successinfo=True)

    def addpermissions(self, requiredpermissions):
        logging.log("Adding permissions to AndroidManifest.xml...", True)
        content = read_file(self.androidmanifestpath)
        # Only add permissions that are not already there
        permissionstoadd = []
        for permission in requiredpermissions:
            permissionfull = f"<uses-permission android:name=\"{permission}\"/>"
            if permissionfull in content:
                logging.log(f"Skipping permission {permission} as it already exists in AndroidManifest.xml", False)
            else:
                permissionstoadd.append(permission)
        if permissionstoadd:
            tryexistingpermissions = ('android.permission.GET_ACCOUNTS', 'android.permission.SYSTEM_ALERT_WINDOW',
                                      'android.permission.WRITE_EXTERNAL_STORAGE', 'com.android.vending.CHECK_LICENSE',
                                      'android.permission.INTERNET', 'android.permission.WAKE_LOCK',
                                      'android.permission.ACCESS_NETWORK_STATE', 'android.permission.ACCESS_WIFI_STATE',
                                      'android.permission.VIBRATE', 'com.android.vending.BILLING',
                                      'com.google.android.c2dm.permission.RECEIVE')
            found = False
            for tryexistingpermission in tryexistingpermissions:
                tryexistingpermissionfull = f"<uses-permission android:name=\"{tryexistingpermission}\"/>"
                if tryexistingpermissionfull in content:
                    found = True
                    for addingpermission in requiredpermissions:
                        addingpermissionfull = f"<uses-permission android:name=\"{addingpermission}\"/>"
                        logging.log(f"Adding permission {addingpermission}"
                            f" next to existing permission {tryexistingpermission}"
                            f" in AndroidManifest.xml...", False)
                        content = content.replace(tryexistingpermissionfull, f"{addingpermissionfull}\n\t{tryexistingpermissionfull}")
                    break
            if not found:
                raise Exception("Failed to add permissions to AndroidManifest.xml because no existing permissions "
                                "were found")
            logging.log(f"Updating AndroidManifest.xml file...", False)
            write_file(self.androidmanifestpath, content)
            logging.log(f"Successfully updated AndroidManifest.xml file", False, successinfo=True)
        logging.log("Successfully added permissions to AndroidManifest.xml", True, successinfo=True)

    def addlauncherservice(self):
        # AndroidManifest.xml
        logging.log("Adding launcher service to AndroidManifest.xml...", True)
        content = read_file(self.androidmanifestpath)
        launcherservice = "<service android:name=\"com.android.support.Launcher\" android:enabled=\"true\"\n\t\tandroid:exported=\"false\" android:stopWithTask=\"true\" />"
        if launcherservice in content:
            logging.log(f"Not adding launcher service to AndroidManifest.xml as it already exists", True,
                        special=True, success=True)
        else:
            if "</application>\n</manifest>" in content:
                content = content.replace("</application>\n</manifest>",
                                          f"\t{launcherservice}\n\t</application>\n</manifest>")
            else:
                raise Exception("Failed to add launcher service to AndroidManifest.xml because application end tag "
                                "was not found")
            logging.log(f"Updating AndroidManifest.xml file...", False)
            write_file(self.androidmanifestpath, content)
            logging.log(f"Successfully updated AndroidManifest.xml file", False, successinfo=True)
            logging.log("Successfully added launcher service to AndroidManifest.xml", True, successinfo=True)

        # mainactivity file
        logging.log("Adding launch activity to mainactivity file...", True)
        logging.log("Adding launch activity code to onCreate method...", False)
        launchactivitycode = "\tinvoke-static {p0}, Lcom/android/support/Main;->Start(Landroid/content/Context;)V"
        content = read_file(self.mainactivitypath)
        lines = content.splitlines()
        if launchactivitycode in lines:
            logging.log(f"Not adding launch activity code to mainactivity file as it already exists", True,
                        special=True, successinfo=True)
        else:
            if ".method protected onCreate(Landroid/os/Bundle;)V" not in content:
                raise Exception("Failed to add launch activity code to mainactivity file because onCreate method was "
                                "not found")
            oncreateline = lines.index(".method protected onCreate(Landroid/os/Bundle;)V")
            lines.insert(oncreateline + 1,
                         "    invoke-static {p0}, Lcom/android/support/Main;->Start(Landroid/content/Context;)V"
                         + "\n")
            content = "\n".join(lines)
            logging.log("Successfully added launch activity code to onCreate method...", False, successinfo=True)
            logging.log(f"Updating mainactivity file...", False)
            write_file(self.mainactivitypath, content)
            logging.log(f"Successfully updated mainactivity file", False, successinfo=True)
            logging.log("Successfully added launch activity to mainactivity file", True, successinfo=True)

    def addmodmenusmali(self):
        logging.log(f"Adding mod menu smali to {self.newapkpath}...", True)
        smaliclassesfolders = [folder for folder in self.smalifolders
                               if os.path.basename(folder).startswith("smali_classes")]
        if not smaliclassesfolders:
            newsmaliclassesfoldername = "smali_classes"
        else:
            lastsmaliclassesfoldername = os.path.basename(smaliclassesfolders[-1])
            lastsmaliclassesnumber = readaftersubstring("smali_classes", lastsmaliclassesfoldername)
            try:
                newsmaliclassesnumber = str(int(lastsmaliclassesnumber) + 1)
            except ValueError:
                newsmaliclassesnumber = "2"
            newsmaliclassesfoldername = f"smali_classes{newsmaliclassesnumber}"
        newsmaliclassesfolder = os.path.join(self.newapkpath, newsmaliclassesfoldername)
        logging.log(f"Creating new smali_classes folder in {self.newapkpath}: {newsmaliclassesfoldername}...", False)
        os.mkdir(newsmaliclassesfolder)
        logging.log(f"Successfully created {newsmaliclassesfoldername} folder in {self.newapkpath}", False, successinfo=True)
        logging.log(f"Adding mod menu smali to {newsmaliclassesfoldername}...", False)
        copydirectory(self.modmenusmalifolder, os.path.join(newsmaliclassesfolder, os.path.basename(self.modmenusmalifolder)),
                      cancelifexists=False, loggingimportance=False)
        logging.log(f"Successfully added mod menu smali to {self.newapkpath}", True, successinfo=True)

    def addmodmenulib(self):
        logging.log(f"Adding mod menu lib to {self.newapkpath}...", True)
        found = False
        for libfolder in self.libfolders:
            libfoldername = os.path.basename(libfolder)
            logging.log(f"Found {libfoldername} lib folder in {self.newapkpath}", False)
            if libfoldername in self.deletelibs:
                logging.log(f"Deleting {libfoldername} lib folder in {self.newapkpath}", False)
                removedirectory(libfolder)
                continue
            for modmenulibfolder in self.modmenulibfolders:
                modmenulibfoldername = os.path.basename(modmenulibfolder)
                if libfoldername == modmenulibfoldername:
                    found = True
                    modmenulibfile = os.path.join(modmenulibfolder, self.modmenulibname)
                    newlibfile = os.path.join(libfolder, self.modmenulibname)
                    logging.log(f"Adding mod menu lib {modmenulibfile} to {libfoldername}...", False)
                    if not self.newapkalreadyexists and os.path.isfile(newlibfile):
                        raise Exception(f"Lib file with same name as mod menu lib file already exists at {newlibfile}")
                    else:
                        copyfile(modmenulibfile, newlibfile, cancelifexists=False, loggingimportance=False)
        if found:
            logging.log(f"Successfully added mod menu lib to {self.newapkpath}", True, successinfo=True)
        else:
            raise Exception(f"Could not add mod menu lib to {self.newapkpath} because no lib folders were found")


class APKEasyTool:
    def __init__(self,
                 directory=None,
                 apktoolpath=None,
                 apksignerpath=None,
                 zipalignpath=None,
                 heapsizexms=None,
                 heapsizexmx=None
                 ):
        # If not specified, directory defaults to current working directory
        self.directory = directory if directory else os.path.join(os.getcwd(), "LGL Mod Menu Installer", "Temp")
        self.defaultdecompilepath = os.path.join(self.directory, "Decompiled APKs")
        self.defaultcompilepath = os.path.join(self.directory, "Compiled APKs")
        self.apktoolpath = apktoolpath if apktoolpath else "apktool.jar"
        self.apksignerpath = apksignerpath if apksignerpath else "apksigner.jar"
        self.zipalignpath = zipalignpath if zipalignpath else "zipalign.exe"
        self.heapsizexms = str(heapsizexms) if heapsizexms else None
        self.heapsizexmx = str(heapsizexmx) if heapsizexmx else None
        createdirectory(self.directory, overwriteifexists=False)
        createdirectory(self.defaultdecompilepath, overwriteifexists=False)

    @staticmethod
    def _command(*args):
        return subprocess.Popen(args, shell=True).wait()

    def decompile(self, apkpath, outputpath=None, overwriteifexists=True, cancelifexists=False):
        """

        Decompiles an apk

        """
        raise NotImplementedError("decompile function not implemented")
        if os.path.isdir(apkpath):
            raise IsADirectoryError(f"Failed to decompile apk {apkpath}: Expected apk file, "
                                    f"got folder.")
        if getfileextension(apkpath) != "apk":
            raise IllegalArgumentException(f"Failed to decompile apk {apkpath}: Expected apk file, "
                                           f"got {getfileextension(apkpath)} file.")
        if not outputpath:
            outputpath = self.defaultdecompilepath + removefileextension(os.path.basename(apkpath))
        decompilepath = outputpath
        logging.log(f"Decompiling apk {apkpath} to {decompilepath}", True, True, True)
        assertfileexists(apkpath)
        if os.path.isdir(decompilepath) and cancelifexists:
            raise FolderExistsError(f"Failed to decompile apk {apkpath}: Decompiled apk already exists at path {decompilepath}")
        if os.path.isdir(decompilepath) and not overwriteifexists:
            logging.log(f"Decompiled apk already exists at path {decompilepath}."
                        f" Using this decompiled apk instead of overwriting it.", True, True, special=True)
            return
        else:
            logging.log(f"Overwriting decompiled apk {decompilepath}...", True, True, special=True)
        try:
            _command(DECOMPILEAPK)
        except Exception:
            removedirectory(decompilepath)
            raise
        logging.log(f"Successfully decompiled apk {apkpath} to {decompilepath}", True, True, True, successinfo=True)

    def _zipalign(self, apkpath, outputpath, signapk=True, overwriteifexists=True, cancelifexists=False):
        """

        FIXME: Correct documentation
        Compiles and signs a decompiled apk
        Signs apk (after zipalinging) if signapk is True
        Zipaligns apk (before signing) if usezipalign is True

        """

    def _sign(self, apkpath, outputpath, overwriteifexists=True, cancelifexists=False):
        """

        FIXME: Correct documentation
        Compiles and signs a decompiled apk
        Signs apk (after zipalinging) if signapk is True
        Zipaligns apk (before signing) if usezipalign is True

        """

    def compile(self, decompiledapkpath, outputpath=None, signapk=True, zipalignapk=True, overwriteifexists=True,
                cancelifexists=False):
        """

        Compiles and signs a decompiled apk
        Signs apk (after zipalinging) if signapk is True
        Zipaligns apk (before signing) if zipalignapk is True

        """
        # TODO: Refactor siging and zipaligning into separate functions. Can sign, or zipalign (which both zipaligns
        # and does the signing itself by internally calling _sign)
        raise NotImplementedError("compile function not implemented")
        if not outputpath:
            outputpath = self.defaultcompilepath + os.path.basename(decompiledapkpath)
        compilepath = os.path.join(os.path.dirname(outputpath),
                                   f"temp_{os.path.basename(outputpath)}")
        logging.log(f"Compiling apk {decompiledapkpath} to {compilepath}", True, True, True)
        assertfolderexists(decompiledapkpath)
        # if os.path.isfile(compilepath):
        #     if cancelifexists:
        #         raise FolderExistsError(f"Failed to compile apk {decompiledapkpath}: APK already exists at path"
        #                             f" {compilepath}")
        #     elif not overwriteifexists:
        #         logging.log(f"APK already exists at path {compilepath}. Aborting compilation...", True, True,
        #                     special=True)
        #     else:
        #         logging.log(f"Overwriting compiled apk {compilepath}...", True, True, special=True)
        if os.path.isfile(compilepath) and overwriteifexists:
            logging.log(f"Overwriting compiled apk at path {compilepath}...", True, True, special=True)
            skipcompile = False
        elif os.path.isfile(compilepath) and cancelifexists:
            raise FolderExistsError(f"Failed to compile apk {decompiledapkpath}: APK already exists at path"
                                    f" {compilepath}")
        elif os.path.isfile(compilepath) and not overwriteifexists:
                logging.log(f"APK already exists at path {compilepath}. Aborting compilation...", True, True,
                            special=True)
                skipcompile = True
        else:
            skipcompile = False
        if not skipcompile:
            try:
                _command(COMPILEAPK)
            except Exception:
                removefile(compilepath)
                raise
            else:
                logging.log(f"Successfully compiled apk {decompiledapkpath} to {compilepath}", True, True, True,
                    successinfo=True)
        if zipalignapk:
            try:
                zipalignpath = f"{compilepath}_zipaligned"
                if os.path.isfile(zipalignpath) and overwriteifexists:
                    logging.log(f"Overwriting zipaligned apk at path {zipalignpath}...", True, True, special=True)
                    skipzipalign = False
                elif os.path.isfile(zipalignpath) and cancelifexists:
                    raise FolderExistsError(f"Failed to zipalign apk {decompiledapkpath}: APK already exists at path"
                                            f" {zipalignpath}")
                elif os.path.isfile(zipalignpath) and not overwriteifexists:
                    logging.log(f"APK already exists at path {zipalignpath}. Aborting zipaligning...", True, True,
                                special=True)
                    skipzipalign = True
                else:
                    skipzipalign = False
                if not skipzipalign:
                    try:
                        _command(ZIPALIGNAPK)
                    except Exception:
                        removefile(compilepath)
                        raise
                    else:
                        logging.log(f"Successfully zipaligned apk {compilepath} to {zipalignpath}", True, True, True,
                                    successinfo=True)
            finally:
                # Delete temp APK file, whether we zipaligned or skipped it
                removefile(compilepath)


if platform.system() != "Windows":
    raise OSError("Sorry, this tool is only compatible with Windows")

logging = Logging(colorized=True,
                  printwarnings=True,
                  printimportant=True,
                  printveryimportant=True,
                  printsuperimportant=True,
                  printspecial=True,
                  donotprintsuccessinfo=False,
                  overridedonotprintifspecial=True,
                  printall=True,
                  printnone=False
                  )
try:
    modmenu = ModMenuInstall(r"C:\Users\zachy\OneDrive\Documents\APK Easy Tool\1-Decompiled APKs\PixelGun3DV22.9.1armv7_sigkill",
               r"C:\Users\zachy\OneDrive\Documents\APK Easy Tool\1-Decompiled APKs\Modded PixelGun3DV22.9.1armv7_sigkill",
               r"C:\Users\zachy\OneDrive\Documents\APK Easy Tool\1-Decompiled APKs\app-debug",
               r"libModMenu.so",
               #newappname="Pixel Gun 3D Modded by HorridModz",
               deletelibs=["arm64-v8a"],
               overwriteifexists=False,
               cancelifexists=False)
except Exception:
    # This code exists to make sure that we know when an exception occurs, in case the error message
    # happens to print before the normal print messages go through
    logging.warning("Failed to install mod menu")
    raise